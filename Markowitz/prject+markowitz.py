# -*- coding: utf-8 -*-
"""Prject+markowitz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QnJ2sR7FWV-kgWhlp56USpAHwGoxC6Y8
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Données
tickers = ['AAPL', 'MSFT', 'GOOG']
data = yf.download(tickers, start='2015-01-01', end='2023-01-01')

returns = np.log(data / data.shift(1)).dropna()

returns.plot(figsize=(10, 5), title='Rendements journaliers')

from scipy.stats import norm

def black_scholes(S, K, T, r, sigma):
    d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
    d2 = d1 - sigma*np.sqrt(T)
    price = S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)
    delta = norm.cdf(d1)
    gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
    return price, delta, gamma

# Plot Greeks
S = np.linspace(50, 150, 100)
K, T, r, sigma = 100, 1.0, 0.05, 0.2
prices, deltas, gammas = zip(*[black_scholes(s, K, T, r, sigma) for s in S])

plt.figure(figsize=(12,4))
plt.subplot(121)
plt.plot(S, prices)
plt.title('Option Price vs. Stock Price')

plt.subplot(122)
plt.plot(S, deltas, label='Delta')
plt.plot(S, gammas, label='Gamma')
plt.title('Greeks vs. Stock Price')
plt.legend()
plt.show()

# --- Portfolio Optimization Functions ---
returns.head()
returns = returns['Close']  # Keep only close returns
expected_returns = returns.mean() * 252

def portfolio_volatility(weights, cov_matrix):
    return np.sqrt(weights.T @ cov_matrix @ weights)

def sharpe_ratio(weights, expected_returns, cov_matrix, risk_free_rate=0.02):
    port_return = np.dot(weights, expected_returns)
    port_volatility = portfolio_volatility(weights, cov_matrix)
    return (port_return - risk_free_rate) / port_volatility

def efficient_portfolio(expected_returns, cov_matrix, target_return):
    n = len(expected_returns)
    init_guess = np.ones(n) / n
    bounds = [(0, 1)] * n
    constraints = [
        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},
        {'type': 'eq', 'fun': lambda w: np.dot(w, expected_returns) - target_return}
    ]
    result = minimize(lambda w: portfolio_volatility(w, cov_matrix),
                      init_guess, method='SLSQP', bounds=bounds, constraints=constraints)
    return result.x

# --- Compute Optimal Portfolio (Max Sharpe Ratio) ---
cov_matrix = returns.cov() * 252         # Annualized
n_assets = len(tickers)

result = minimize(lambda w: -sharpe_ratio(w, expected_returns, cov_matrix),
                  x0=np.ones(n_assets) / n_assets,
                  bounds=[(0, 1)] * n_assets,
                  constraints=[{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}])
optimal_weights = result.x

# --- Plot Efficient Frontier ---
simulated_returns = np.linspace(expected_returns.min(), expected_returns.max(), 100)
simulated_volatilities = []

for r in simulated_returns:
    try:
        w = efficient_portfolio(expected_returns, cov_matrix, r)
        simulated_volatilities.append(portfolio_volatility(w, cov_matrix))
    except:
        simulated_volatilities.append(np.nan)

plt.figure(figsize=(10, 6))
plt.plot(simulated_volatilities, simulated_returns, 'b-', label='Efficient Frontier')
opt_ret = np.dot(optimal_weights, expected_returns)
opt_vol = portfolio_volatility(optimal_weights, cov_matrix)
plt.scatter(opt_vol, opt_ret, color='red', label='Max Sharpe Portfolio')
plt.xlabel('Volatility (σ)')
plt.ylabel('Return (μ)')
plt.title('Efficient Frontier and Optimal Portfolio')
plt.legend()
plt.grid(True)
plt.show()

# --- Monthly Rebalancing (Max Sharpe) ---
rebalanced_weights = pd.DataFrame(index=returns.resample('M').last().index, columns=tickers)

for date in rebalanced_weights.index:
    subset = returns.loc[:date]
    if len(subset) < 60:  # Skip short samples
        continue
    expected = subset.mean() * 252
    cov = subset.cov() * 252
    res = minimize(lambda w: -sharpe_ratio(w, expected, cov),
                   x0=np.ones(n_assets) / n_assets,
                   bounds=[(0, 1)] * n_assets,
                   constraints=[{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}])
    if res.success:
        rebalanced_weights.loc[date] = res.x

rebalanced_weights.ffill().plot(figsize=(12, 5), title='Monthly Rebalanced Portfolio Weights')
plt.ylabel("Weight")
plt.grid(True)
plt.show()

np.random.seed(42)
days = 30
dt = 1/252
mu, sigma_sim = 0.05, 0.2
S0, K = 100, 100

# Simulate stock path
stock_prices = S0 * np.exp(np.cumsum((mu - 0.5*sigma_sim**2)*dt + sigma_sim*np.sqrt(dt)*np.random.randn(days)))

# Delta hedging
cash = black_scholes(S0, K, days/252, 0.05, sigma_sim)[0]  # Initial premium
shares = 0
hedged_pnl = [0]
unhedged_pnl = [0]

for t in range(1, days+1):
    S = stock_prices[t-1]
    T_remaining = (days - t)/252
    _, delta, _ = black_scholes(S, K, T_remaining, 0.05, sigma_sim)

    # Rebalance shares
    shares_needed = delta
    shares_diff = shares_needed - shares
    cash -= shares_diff * S
    shares = shares_needed

    # Track P&L
    current_value = cash + shares * S
    option_value = black_scholes(S, K, T_remaining, 0.05, sigma_sim)[0]
    hedged_pnl.append(current_value - option_value)
    unhedged_pnl.append(-option_value)  # Short option

plt.plot(hedged_pnl, label='Delta Hedged')
plt.plot(unhedged_pnl, label='Unhedged')
plt.title('Delta Hedging P&L Comparison')
plt.xlabel('Days')
plt.ylabel('P&L')
plt.legend()
plt.show()

# Historical VaR Calculation
portfolio_values = data['Close'][tickers].dot(optimal_weights)
portfolio_returns = portfolio_values.pct_change().dropna()
confidence_level = 0.95
VaR = -np.percentile(portfolio_returns, 100*(1 - confidence_level))

plt.hist(portfolio_returns, bins=50)
plt.axvline(-VaR, color='r', linestyle='--', label=f'VaR at {confidence_level}')
plt.legend()
plt.title('Historical VaR')
plt.show()

# Stress Test: 20% Market Drop
# Select only the 'Close' prices for the assets in the portfolio
stress_loss = (data['Close'][tickers].iloc[-1] * 0.8).dot(optimal_weights) - data['Close'][tickers].iloc[-1].dot(optimal_weights)
print(f'Stress Test Loss: ${stress_loss:.2f}')

# Backtesting VaR
exceptions = portfolio_returns < -VaR
print(f'Exception Rate: {np.mean(exceptions):.2%}')